#include <iostream>

struct Base{
    virtual ~Base() {}
    virtual void f(){
        std::cout << 1;
    }
};

struct Derived: public Base{
private:
        void f() override {
            std::cout << 2;
        }
};

int main() {
    int x;
    std::cin >> x;

    Base b;
    Derived d;
    Base& bb = x > 0 ? b : d;   //что введет пользователь,
                                // невозможно предугадать на этапе компиляции
// тернарный оператор позволяет писать b и d, потому что
// их можно скастовать к Base,
// но это статический тип, тот тип, что известен компилятору
//компилятор оперирует со статическими типами
//но реальный тип может быть другим,
// поэтому компилятор должен поддерживать для полиморфных типов
// некое скрытое поле, которое помогает в runtime понять, какой тип на самом деле
// это и есть RTTI.
// В этом поле лежит указатель на таблицу с информацией о типе
// на нее то процессор и смотрит, чтобы понять, какой тип на самом деле
//и уже в зависимости от этого, решается, какую версию виртуальной ф-ции вызвать
//то есть решение, какую версию метода вызвать, принимается в runtime

//компилятор может проверить только легально ли вызвать такой метод у базового класса
//но не может проверить, например, вдруг вызванная версия наследника окажется private -
//это будет известно только в runtime по той таблице и скрытому полю

bb.f();
}